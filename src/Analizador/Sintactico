/*
 * Organización de Lenguajes y Compiladores 1 A
 * Aux. Emely García
 */

package Analizador; 
import java_cup.runtime.*;
import AST.*;
import java.util.ArrayList;
parser code  
{:
    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
        System.out.println("Error Sintáctico en la Línea " + (s.left) +
        " Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
        
    } 

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la Línea " + 
        (s.left)+ " Columna "+s.right+". Componente " + s.value + 
        " no reconocido."); 
    }  
:} 
terminal mas,menos,div,por;
terminal par1,par2;
terminal mayor,menor,igual,not;
terminal puntoycoma,llave1,llave2,coma;

terminal String pr_if,pr_else, pr_for, pr_while, pr_number, pr_boolean, pr_string, pr_func;
terminal String entero,decimal,cadena,identificador;
non terminal INICIO,EXPRESION,VALOR,CONDICION;
non terminal SENTENCIAS, SENTENCIA,SENTENCIACONTROL,DECLARACION,ASIGNACION,TIPODATO,LLAMADAMF,LISTAPARAMS,IFELSE;
non terminal BLOQUESENTENCIAS, FOR, WHILE, INCREMENTO, FUNCION;
//precedencia
precedence left mayor,menor,igual;
precedence right not;

precedence left mas,menos;
precedence left por,div;


start with INICIO;

INICIO ::= SENTENCIAS:lista {:
AnalizadorLenguaje.sentencias = (ArrayList<Sentencia>) lista;
:};

FUNCION::= pr_func identificador par1 par2 BLOQUESENTENCIAS;

SENTENCIAS ::= SENTENCIAS:sent SENTENCIA:b puntoycoma {:
ArrayList<Sentencia> lista = (ArrayList<Sentencia>) sent;
lista.add((Sentencia)b); 
RESULT = lista;
:}
|SENTENCIA:a puntoycoma {: 
ArrayList<Sentencia> lista = new ArrayList();
lista.add((Sentencia)a); 
RESULT = lista;
:}
;

SENTENCIA ::= DECLARACION :a {: RESULT = a; :}
    | LLAMADAMF:a {: RESULT = a; :};

SENTENCIACONTROL ::= IFELSE
    | FOR
    | WHILE;

BLOQUESENTENCIAS::= llave1 SENTENCIAS llave2
    |llave1  llave2;

FOR::=pr_for par1 ASIGNACION puntoycoma CONDICION puntoycoma INCREMENTO par2 BLOQUESENTENCIAS; 

INCREMENTO::= identificador mas mas;

WHILE::= pr_while par1 CONDICION par2 BLOQUESENTENCIAS;

IFELSE::= pr_if par1 CONDICION par2 BLOQUESENTENCIAS
    |pr_if par1 CONDICION par2 BLOQUESENTENCIAS pr_else BLOQUESENTENCIAS;

LLAMADAMF::= identificador:nombre par1 LISTAPARAMS:array par2 {: RESULT = new LlamadaMetodo((ArrayList<Expresion>) array,(String) nombre);:};

LISTAPARAMS::= LISTAPARAMS:params coma EXPRESION:b {: 
ArrayList<Expresion> lista = (ArrayList<Expresion>) params;
lista.add((Expresion)b); 
RESULT = lista;
:}
|EXPRESION:a 
{: 
ArrayList<Expresion> lista = new ArrayList();
lista.add((Expresion)a); 
RESULT = lista;
:}
| {: RESULT = new ArrayList(); :};



ASIGNACION ::= identificador igual EXPRESION; 

DECLARACION ::= TIPODATO:tipo identificador:nombre {: RESULT = new Declaracion((TipoDatoSimbolo)tipo,nombre,tipoleft,tiporight);  :};

TIPODATO ::= pr_number {: RESULT = TipoDatoSimbolo.NUMERO; :}
    | pr_string {: RESULT = TipoDatoSimbolo.CADENA; :}
    | pr_boolean {: RESULT = TipoDatoSimbolo.BOOLEANO; :};

EXPRESION::=EXPRESION:a mas:c EXPRESION:b {: RESULT = new OperacionAritmeticas((Expresion)a,(Expresion)b,TipoOperacion.SUMA); :}
    |EXPRESION:a menos:c EXPRESION:b {: RESULT = new OperacionAritmeticas((Expresion)a,(Expresion)b,TipoOperacion.RESTA); :}
    |EXPRESION:a div:c EXPRESION:b {: RESULT = new OperacionAritmeticas((Expresion)a,(Expresion)b,TipoOperacion.DIVISION); :}
    |EXPRESION:a por:c EXPRESION:b {: RESULT = new OperacionAritmeticas((Expresion)a,(Expresion)b,TipoOperacion.MULTIPLICACION); :}
    |VALOR:a {: RESULT = a; :} ;

CONDICION::= EXPRESION:a mayor:c EXPRESION:b
    |EXPRESION:a menor:c EXPRESION:b
    |EXPRESION:a igual:c igual EXPRESION:b
    |EXPRESION:a not:c igual EXPRESION:b;


VALOR ::= cadena:a {: RESULT = new OperacionAritmeticas(TipoOperacion.CADENA,(String)a); :}
    |entero:a {: RESULT = new OperacionAritmeticas(TipoOperacion.NUMERO,(String)a); :}
    |decimal:a {: RESULT = new OperacionAritmeticas(TipoOperacion.NUMERO,(String)a); :}
    |identificador:a {: RESULT = new OperacionAritmeticas(TipoOperacion.ID,(String)a); :};